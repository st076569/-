#ifndef MANAGERLIB_H
#define MANAGERLIB_H

////////// managerlib ////////////////////////////////////////////////////////
// Автор    : Баталов Семен                                                 //
// Дата     : 28.09.2020                                                    //
// Задача   : Взять старый код и распараллелить. При этом эффективность     //
//            должна вырасти.                                               //
//////////////////////////////////////////////////////////////////////////////

#include <iomanip>
#include <iostream>

#include <ctime>
#include <queue>
#include <vector>
#include <exception>

#include <mutex>
#include <thread>
#include <condition_variable>

namespace bat
{
    // Общий вещественный тип
    typedef double Real;
    
    const int MAX_DURATION   = 6;
    const int MAX_DELAY      = 2;
    const int BUFFER_SIZE    = 10;
    
    ////////// struct Task ///////////////////////////////////////////////////
    // Эта структура представляет собой задачу для выполнения.              //
    //////////////////////////////////////////////////////////////////////////
    
    struct Task
    {
        public :
            
            Real duration;      // Продолжительность выполнения задачи (сек)
            Real start;         // Время поступления задачи (сек)
            bool isFinal;       // Завершающая задача?
            int  id;            // Уникальный номер задачи
            
        public :
            
            // (1) Конструктор
            Task();
            
            // (2) Конструктор копирования
            Task(const Task& task) = default;
            
            // (3) Перегрузка оператора присваивания
            Task& operator=(const Task& task) = default;
            
            // (4) Выводит информацию о задании на экран
            void print() const;
            
            // (5) Обнуляет поля
            void clear();
            
            // (6) Деструктор
            ~Task() = default;
    };
    
    ////////// struct Queue //////////////////////////////////////////////////
    // Эта структура характеризует очередь с возможностью параллельной      //
    // обработки задач в ней.                                               //
    //////////////////////////////////////////////////////////////////////////
    
    struct Queue
    {
        public :
            
            std::queue<Task>        dataList;   // Очередь задач
            std::condition_variable dataCond;   // Усл. переменная для записи
            std::mutex              printMut;   // "mutex" для вывода на экран
            std::mutex              dataMut;    // "mutex" для добавл. задачи
            int                     step;       // Очередной номер для вывода
            
        public :
            
            // (1) Конструктор
            Queue();
            
            // (2) Конструктор копирования
            Queue(const Queue& newQueue) = delete;
            
            // (3) Перегрузка оператора присваивания
            Queue& operator=(const Queue& newQueue) = delete;
            
            // (4) Обнуляет поля
            void clear();
            
            // (5) Деструктор
            ~Queue() = default;
    };
    
    ////////// class Buffer //////////////////////////////////////////////////
    // Класс, содержащий информацию о количестве и очередности поступления  //
    // задач. Производит закрузку задач в очередь диспетчера.               //
    //////////////////////////////////////////////////////////////////////////
    
    class Buffer
    {
        private :
            
            std::vector<Task> tasks_;  // Массив потенциальных задач
            Real startPoint_;          // Точка начала отсчета
            int  step_;                // Номер очередной задачи
            
        public :
            
            // (1) Конструктор
            Buffer();
            
            // (2) Конструктор копирования
            Buffer(const Buffer& buffer) = default;
            
            // (3) Перегрузка оператора присваивания
            Buffer& operator=(const Buffer& buffer) = default;
            
            // (4) Инициализировать массив задач
            void initialize();
            
            // (5) Зафиксировать точку отсчета времени
            void setStartPoint(Real start);
            
            // (6) Если пришла очередная задача
            bool haveTask() const;
            
            // (7) Пуст ли буфер?
            bool empty();
            
            // (8) Вернуть поступившую задачу
            Task getTask();
            
            // (9) Возвращает счетчик в начало
            void back();
            
            // (10) Выводит информацию о заданиях на экран
            void print() const;
            
            // (11) Обнуляет поля
            void clear();
            
            // (12) Деструктор
            ~Buffer() = default;
    };
    
    ////////// void delay ////////////////////////////////////////////////////
    // Осуществляет задержку на время "duration" в секундах.                //
    //////////////////////////////////////////////////////////////////////////
    
    void delay(Real duration);
    
    ////////// Real time /////////////////////////////////////////////////////
    // Возвращает время от начала работы программы в секундах.              //
    //////////////////////////////////////////////////////////////////////////
    
    Real time();
    
    ////////// void dataPreparation //////////////////////////////////////////
    // Добавляет в очередь очередной элемент. Предназначена для вызова в    //
    // отдельном потоке.                                                    //
    //////////////////////////////////////////////////////////////////////////
    
    void dataPreparation(Queue& dataQueue, Buffer& taskSeq);
    
    ////////// void dataProcessing ///////////////////////////////////////////
    // Считывает из очереди один элемент и обрабатывает его. Предназначена  //
    // для вызова в отдельном потоке.                                       //
    //////////////////////////////////////////////////////////////////////////
    
    void dataProcessing(Queue& dataQueue);
    
    ////////// void parallelManager //////////////////////////////////////////
    // Обрабатывает последовательность элементов параллельно в нескольких   //
    // потоках.                                                             //
    //////////////////////////////////////////////////////////////////////////
    
    void parallelManager(Buffer& taskSeq);
    
    ////////// void consistentManager ////////////////////////////////////////
    // Обрабатывает последовательность элементов последовательно в одном    //
    // потоке.                                                              //
    //////////////////////////////////////////////////////////////////////////
    
    void consistentManager(Buffer& taskSeq);
    
    ////////// void message //////////////////////////////////////////////////
    // Инструкция.                                                          //
    //////////////////////////////////////////////////////////////////////////
    
    void message();
}

#endif